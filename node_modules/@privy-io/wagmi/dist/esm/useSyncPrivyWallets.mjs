import{useEffect as e}from"react";import{useConfig as t,useReconnect as n}from"wagmi";import{injected as a}from"wagmi/connectors";import{useWallets as o,usePrivy as r,useConnectWallet as c,useConnectOrCreateWallet as i,useLogin as s}from"@privy-io/react-auth";const d=({setActiveWalletForWagmi:a})=>{let{wallets:d,ready:w}=o(),{user:p}=r(),I=t(),{reconnect:y}=n();c({onSuccess:async({wallet:e})=>{await(I.storage?.removeItem(`${e.meta.id}.disconnected`)),a||(await(I.storage?.setItem("recentConnectorId",e.meta.id)),y())}}),i({onSuccess:async({wallet:e})=>{await(I.storage?.removeItem(`${e.meta.id}.disconnected`)),a||(await(I.storage?.setItem("recentConnectorId",e.meta.id)),y())}}),s({onComplete:async({user:e,loginAccount:t})=>{t&&"wallet"!==t.type&&e.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType))&&(await(I.storage?.removeItem("io.privy.wallet.disconnected")),y())}}),e((()=>{a&&(async()=>{let e=a({wallets:d,user:p});if(!e)return m(I),void y();let[t]=await l([e],I);t?(await u(e,t,I),y()):console.error(`Failed to setup connector for ${e.address}`)})()}),[d,p,a]),e((()=>{a||l(d,I).then((()=>{w&&y()}))}),[d,!a,w])};let l=async(e,t)=>{let n=await Promise.all(e.map((async e=>{let n=await e.getEthereumProvider(),o=t.connectors.find((t=>t.id===e.meta.id));if(o)return o;let r=a({target:{provider:n,id:e.meta.id,name:e.meta.name,icon:e.meta.icon}});return t._internal.connectors.setup(r)})));return t._internal.connectors.setState(n),n},m=e=>{e._internal.connectors.setState([]),e.setState((e=>({chainId:e.chainId,connections:new Map,current:null,status:"disconnected"})))},u=async(e,t,n)=>{await Promise.all([n.storage?.removeItem(`${e.meta.id}.disconnected`),n.storage?.setItem("recentConnectorId",t.id)]);let a=Number(e.chainId.replace("eip155:",""));n.chains.find((e=>e.id===a))||(a=n.chains[0].id);let o=new Map([[t.uid,{accounts:[e.address],chainId:a,connector:t}]]);n.setState((e=>({...e,chainId:a,connections:o,current:t.uid,status:"connected"})))};export{d as useSyncPrivyWallets};
